<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>D3 World Map</title>
    <style>
        .neighborhoodOutline {
            stroke: navy;
            stroke-width: 0.5px;
            fill: gray;

        }

        .neighborhoodInnerPath {
            stroke-width: 3 px;
            fill: none;
        }

        .topPoly {
            stroke: white;
            fill: #660000;
        }


    </style>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/topojson.v0.min.js"></script>
    <script src="http://www.d3plus.org/js/d3.js"></script>
    <script src="http://www.d3plus.org/js/d3plus.js"></script>
</head>
<body>
<script type="text/javascript">
    var width = 900;
    var height = 600;
    var rotate = [122, 0, 0];
    var center = [0, 47.3097];
    var scale  = 150000;
    var offset = [1141.329833984375 - 263 + width / 2, 142582.609375 + 30];


    var projection = d3.geo.mercator()
            .rotate(rotate)
            .scale(scale)
            .translate(offset)
            .precision(.5);

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height * 2);

    var path = d3.geo.path()
            .projection(projection);

    var neighborhoodGroup = svg.append("g")
            .attr('id', 'neighborhoodGroup');

    /*parses json, call back function selects all paths (none exist yet)
            and joins data (all neighborhoods) with each path. since there are no
            paths, all data points are waiting in 'update.enter'. calling
            'enter()' gives us these points, and appends a path for each of them,
            attributing a path and id to each.*/

    //maybe don't need this
    var topoGeometries;

    d3.json("json/neighborhoods.json", function(error, topology) {

        topoGeometries = topojson.object(topology, topology.objects.neighborhoods)
                .geometries;

        neighborhoodGroup.selectAll("path")
                .data(topoGeometries)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("class", "neighborhoodOutline")
                .attr("id", function(d) {
                        return "n_" + d.id
                });
//                .attr("fill", function() {
//                    var letters = '0123456789ABCDEF'.split('');
//                    var color = '#';
//                    for (var i = 0; i < 6; i++ ) {
//                        color += letters[Math.floor(Math.random() * 16)];
//                    }
//                    return color;
//                });


        neighborhoodGroup.selectAll(".neighborhoodInnerPath")
                .data(topoGeometries)
                .enter()
                .append("path")
                .attr("neighborhoodBounds", path)
                .attr("class", "neighborhoodInnerPath")
                .attr("id", function(d) {
                    return "inner_" + d.id;
                })
                .attr("d", function(d) {
                    var neighborhoodBoundsString = this.getAttribute("neighborhoodBounds");

                    //remove 'M' at beginning of path and find all subsequent coordinates by
                    //splitting on 'L'
                    var pathCoords = neighborhoodBoundsString.substring(1).split('L');
                    var pathCoords2d = [];

                    //transform pathCoords array into array of 2-d arrays
                    for (var i = 0; i < pathCoords.length; i++) {
                        var bothCoords = pathCoords[i].split(',');
                        pathCoords2d[i] = [parseFloat(bothCoords[0]), parseFloat(bothCoords[1])];

                    }

                    //find largest rectangle in polygon
                    if (pathCoords2d.length > 2) {

                        //generate largest inscribed rectangle for overall polygon
                        var rectangle = d3plus.geom.largestRect(pathCoords2d, {
                            angle: [0, 90, 270], nTries: 50, tolerance: 0.02
                        });
                        svg.append("rect")
                                .attr("width", rectangle[0].width)
                                .attr("height", rectangle[0].height)
                                .attr("x", rectangle[0].cx - (rectangle[0].width / 2))
                                .attr("y", rectangle[0].cy - (rectangle[0].height / 2))
                                .attr("transform", "rotate(" + rectangle[0].angle + "," + rectangle[0].cx + "," + rectangle[0].cy + ")")
                                .attr("id", function() {
                                    return "rect_" + d.id;
                                })
                                .attr("fill", "#9999FF")
                                .attr("opacity", "0.5");

//                        //append angle as text on to rectangle
//                        svg.append("text").attr("x", rectangle[0].cx)
//                                .attr("y", rectangle[0].cy)
//                                .text(function(d) { return rectangle[0].angle; });

                        //find second rectangle--one that fits in remaining space
                        //longer side -> width
                        //shorter side -> height
                        var rectTopYCoord;
                        var rectRightXCoord;
                        var rectLowYCoord;
                        var rectLeftXCoord;

                        //find four corners of rectangle
                        if (rectangle[0].angle == 90 || rectangle[0].angle == 270) {
                            rectLowYCoord = rectangle[0].cy + (rectangle[0].width / 2);
                            rectRightXCoord = rectangle[0].cx + (rectangle[0].height / 2);
                            rectTopYCoord = rectangle[0].cy - (rectangle[0].width / 2);
                            rectLeftXCoord = rectangle[0].cx - (rectangle[0].height / 2);
                        } else {
                            rectLowYCoord = rectangle[0].cy + (rectangle[0].height / 2);
                            rectRightXCoord = rectangle[0].cx + (rectangle[0].width / 2);
                            rectTopYCoord = rectangle[0].cy - (rectangle[0].height / 2);
                            rectLeftXCoord = rectangle[0].cx - (rectangle[0].width / 2);
                        };

                        //mark corners of rectangle with circles -- for debugging
                        markFourCorners(rectTopYCoord, rectLowYCoord, rectLeftXCoord, rectRightXCoord);
//
//                        if (d.id == 38) {
//                            debugger;
//                        }

                        //TODO: special case for industrial district
                        if (d.id != 41) {
                            var topPoly = generateTopPolygon(d, rectTopYCoord, rectLowYCoord, rectLeftXCoord, rectRightXCoord,
                                    pathCoords2d);
//                                                    var topRectangle = generateTopRectangle(topPoly, d);
                        }
                    }



                    return null;
                });






    });

    function markFourCorners(rectTopYCoord, rectLowYCoord, rectLeftXCoord, rectRightXCoord) {
        svg.append("circle").attr("cy", rectTopYCoord)
                .attr("cx", rectRightXCoord)
                .attr("r", 2);

        svg.append("circle").attr("cy", rectTopYCoord)
                .attr("cx", rectLeftXCoord)
                .attr("r", 2);

        svg.append("circle").attr("cy", rectLowYCoord)
                .attr("cx", rectRightXCoord)
                .attr("r", 2);

        svg.append("circle").attr("cy", rectLowYCoord)
                .attr("cx", rectLeftXCoord)
                .attr("r", 2);
    }

    function generateTopPolygon(d,  rectTopYCoord,
                                rectLowYCoord, rectLeftXCoord, rectRightXCoord, pathCoords2d) {

        //compare corners of rectangle with coords of poly--for each corner,
        // compare:

        var topRect;
        var topPoly = [];

        topPoly[0] = [rectRightXCoord, rectTopYCoord];
        topPoly[1] = [rectLeftXCoord, rectTopYCoord];

        //determine which side to start drawing polygon from:
        //we draw first line of top polygon fom right to left,
        //must start drawing remainder of polygon from left side.

        var countFromStart = 0;
        var countFromEnd = pathCoords2d.length - 1;

        //assume that first point of outer poly is not in top poly
        while (countFromStart < pathCoords2d.length - 1 && pathCoords2d[countFromStart + 1][1] >= rectTopYCoord) {
            countFromStart++;
        }
        while (countFromEnd > 0 && pathCoords2d[countFromEnd - 1][1] >= rectTopYCoord) {
            countFromEnd--;
        }

        if (Math.abs(countFromStart - countFromEnd) > 1) { //can't make polygon out of two points


            if (countFromStart == 0 || countFromEnd == pathCoords2d.length - 1) { //first point of poly IS in topPoly

                countFromStart = 0;
                while (countFromStart < pathCoords2d.length - 1 &&
                pathCoords2d[countFromStart + 1][1] < rectTopYCoord) {
                    countFromStart++;
                }

//                //generate first intersection point
//                generateIntersectionPointFromStart(pathCoords2d, countFromStart, rectTopYCoord, d);
//                generateIntersectionPointFromEnd(pathCoords2d, countFromEnd, rectTopYCoord, d);
//
//                //generate second intersection point
//                generateIntersectionPointFromEnd(pathCoords2d, countFromEnd, rectTopYCoord, d, -1);

                //now count from start represents first coord lower than
                //top of rectangle
                countFromEnd = pathCoords2d.length - 1;
                while (countFromEnd > 0 &&
                pathCoords2d[countFromEnd - 1][1] < rectTopYCoord) {
                    countFromEnd--;
                }


                //figure out which point is closer
                //first check distance from our point to point found by
                //moving from the start
                if (true) {

                    var distanceToPStart = Math.sqrt(
                            Math.pow(pathCoords2d[countFromStart][0] - rectLeftXCoord, 2) +
                            Math.pow(pathCoords2d[countFromStart][1] - rectTopYCoord, 2)
                    );

                    //check distance from our point to point found by
                    //moving from the end
                    var distanceToPEnd = Math.sqrt(
                            Math.pow(pathCoords2d[countFromEnd][0] - rectLeftXCoord, 2) +
                            Math.pow(pathCoords2d[countFromEnd][1] - rectTopYCoord, 2)
                    );

                    var topPolyNextIndex = 2;


                    if (distanceToPStart < distanceToPEnd) {

                        //loop from count from start to start of outer poly path
                        for (var i = countFromStart; i >= 0; i--) {
                            topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                            topPolyNextIndex++;
                        }

                        //loop from end of poly path to count from end
                        for (var i = pathCoords2d.length - 1; i >= countFromEnd; i--) {
                            topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                            topPolyNextIndex++;
                        }
                    } else { //distanceToPEnd <= distanceToPStart
                        //loop from count from end to start of outer poly path
                        for (var i = countFromEnd; i < pathCoords2d.length; i++) {
                            topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                            topPolyNextIndex++;
                        }

                        //loop from beginning of poly path to count from start
                        for (var i = 0; i <= countFromStart; i++) {
                            topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                            topPolyNextIndex++;
                        }
                    }
                }


            } else { //first point of poly is not in topPoly

//                generateIntersectionPointFromStart(pathCoords2d, countFromStart, rectTopYCoord, d);
//                generateIntersectionPointFromStart(pathCoords2d, countFromEnd, rectTopYCoord, d);



                //figure out which point is closer
                //first check distance from our point to point found by
                //moving from the start
                if (true) {

                    var distanceToPStart = Math.sqrt(
                            Math.pow(pathCoords2d[countFromStart][0] - rectLeftXCoord, 2) +
                            Math.pow(pathCoords2d[countFromStart][1] - rectTopYCoord, 2)
                    );

                    //check distance from our point to point found by
                    //moving from the end
                    var distanceToPEnd = Math.sqrt(
                            Math.pow(pathCoords2d[countFromEnd][0] - rectLeftXCoord, 2) +
                            Math.pow(pathCoords2d[countFromEnd][1] - rectTopYCoord, 2)
                    );

                    var topPolyNextIndex = 2;

                    if (distanceToPStart < distanceToPEnd) {
                        //start at the start
                        //TODO change loop bound to countFromEnd
                        for (var i = countFromStart; i < pathCoords2d.length; i++) {
                            if (pathCoords2d[i][1] < rectTopYCoord) {
                                topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                                topPolyNextIndex++;
                            }
                        }
                    } else {
                        //start at the end
                        for (var i = countFromEnd; i >= 0; i--) {
                            if (pathCoords2d[i][1] < rectTopYCoord) {
                                topPoly[topPolyNextIndex] = [pathCoords2d[i][0], pathCoords2d[i][1]];
                                topPolyNextIndex++;
                            }
                        }
                    }
                }
            }
            //generate path for topPoly
            var pathString = "M" + topPoly[0][0] + "," + topPoly[0][1];
            for (var j = 1; j < topPoly.length; j++) {
                pathString += "L" + topPoly[j][0] + "," + topPoly[j][1];
            }
            svg.append("path").attr("d", pathString)
                    .attr("class", "topPoly")
                    .attr("id", "topPoly_" + d.id);

            return topPoly;
        }
        return null;
    }

    function generateTopRectangle(topPoly, d) {
        //generate top rectangle
        if (topPoly.length > 2) {
            var topRectangle = d3plus.geom.largestRect(topPoly, {
                angle: [0, 90, 270], nTries: 50, tolerance: 0.02
            });

//                            neighborhoodGroup.selectAll("path")
//                                    .data(topoGeometries)
//                                    .enter()
//                                    .append("path")
//                                    .attr("d", path)
//                                    .attr("class", "neighborhoodOutline")
//                                    .attr("id", function(d) {
//                                        return "n_" + d.id
//                                    });

            svg.append("rect")
                    .attr("width", topRectangle[0].width)
                    .attr("height", topRectangle[0].height)
                    .attr("x", topRectangle[0].cx - (topRectangle[0].width / 2))
                    .attr("y", topRectangle[0].cy - (topRectangle[0].height / 2))
                    .attr("transform", "rotate(" + topRectangle[0].angle + "," + topRectangle[0].cx + "," + topRectangle[0].cy + ")")
                    .attr("id", function() {
                        return "topRect_" + d.id;
                    })
                    .attr("fill", function() {
                        var letters = '0123456789ABCDEF'.split('');
                        var color = '#';
                        for (var i = 0; i < 6; i++ ) {
                            color += letters[Math.floor(Math.random() * 16)];
                        }
                        return color;
                    });
            return topRectangle;
        }
    }

    function generateIntersectionPointFromStart(pathCoords2d, countFrom, rectTopYCoord, d) {
        var startPoint = [pathCoords2d[countFrom][0], pathCoords2d[countFrom][1]];
        var endPoint = [pathCoords2d[countFrom + 1][0], pathCoords2d[countFrom + 1][1]];

        var slope = Math.sqrt(Math.pow(startPoint[0] - endPoint[0], 2) + Math.pow(startPoint[1] - endPoint[1], 2));
        var newX = (Math.abs(endPoint[1] - startPoint[1]) / slope) + startPoint[0];

        svg.append("path")
                .attr("d", "M" + startPoint[0] + "," + startPoint[1] + "L" + endPoint[0] + "," + endPoint[1])
                .attr("stroke", "red");

        svg.append("circle").attr("cy", rectTopYCoord)
                .attr("cx", newX)
                .attr("r", 2)
                .attr("fill", "red")
                .attr("id", "startIntersection_" + d.id);

    }

    function generateIntersectionPointFromEnd(pathCoords2d, countFrom, rectTopYCoord, d) {
        var startPoint = [pathCoords2d[countFrom][0], pathCoords2d[countFrom][1]];
        var endPoint = [pathCoords2d[countFrom - 1][0], pathCoords2d[countFrom - 1][1]];

        var slope = Math.sqrt(Math.pow(startPoint[0] - endPoint[0], 2) + Math.pow(startPoint[1] - endPoint[1], 2));
        var newX = (Math.abs(endPoint[1] - startPoint[1]) / slope) + startPoint[0];

        svg.append("path")
                .attr("d", "M" + startPoint[0] + "," + startPoint[1] + "L" + endPoint[0] + "," + endPoint[1])
                .attr("stroke", "red");

        svg.append("circle").attr("cy", rectTopYCoord)
                .attr("cx", newX)
                .attr("r", 2)
                .attr("fill", "red")
                .attr("id", "endIntersection_" + d.id);

    }


</script>
</body>
</html>