<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>D3 World Map</title>
    <style>
        .neighborhoodOutline {
            stroke: navy;
            stroke-width: 0.5px;
            fill: gray;

        }

        .neighborhoodInnerPath {
            stroke-width: 3 px;
            fill: none;
        }


    </style>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/topojson.v0.min.js"></script>
    <script src="http://www.d3plus.org/js/d3.js"></script>
    <script src="http://www.d3plus.org/js/d3plus.js"></script>
</head>
<body>
<script type="text/javascript">
    var width = 900;
    var height = 600;
    var rotate = [122, 0, 0];
    var center = [0, 47.3097];
    var scale  = 150000;
    var offset = [1141.329833984375 - 263 + width / 2, 142582.609375 + 30];


    var projection = d3.geo.mercator()
            .rotate(rotate)
            .scale(scale)
            .translate(offset)
            .precision(.5);

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height * 2);

    var path = d3.geo.path()
            .projection(projection);

    var neighborhoodGroup = svg.append("g")
            .attr('id', 'neighborhoodGroup');

    /*parses json, call back function selects all paths (none exist yet)
            and joins data (all neighborhoods) with each path. since there are no
            paths, all data points are waiting in 'update.enter'. calling
            'enter()' gives us these points, and appends a path for each of them,
            attributing a path and id to each.*/

    //maybe don't need this
    var topoGeometries;

    d3.json("json/neighborhoods.json", function(error, topology) {

        topoGeometries = topojson.object(topology, topology.objects.neighborhoods)
                .geometries;

        neighborhoodGroup.selectAll("path")
                .data(topoGeometries)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("class", "neighborhoodOutline")
                .attr("id", function(d) {
                        return "n_" + d.id
                });
//                .attr("fill", function() {
//                    var letters = '0123456789ABCDEF'.split('');
//                    var color = '#';
//                    for (var i = 0; i < 6; i++ ) {
//                        color += letters[Math.floor(Math.random() * 16)];
//                    }
//                    return color;
//                });


        neighborhoodGroup.selectAll(".neighborhoodInnerPath")
                .data(topoGeometries)
                .enter()
                .append("path")
                .attr("neighborhoodBounds", path)
                .attr("class", "neighborhoodInnerPath")
                .attr("id", function(d) {
                    return "inner_" + d.id;
                })
                .attr("d", function(d) {
                    var neighborhoodBoundsString = this.getAttribute("neighborhoodBounds");

                    //remove 'M' at beginning of path and find all subsequent coordinates by
                    //splitting on 'L'
                    var pathCoords = neighborhoodBoundsString.substring(1).split('L');
                    var pathCoords2d = [];

                    //transform pathCoords array into array of 2-d arrays
                    for (var i = 0; i < pathCoords.length; i++) {
                        var bothCoords = pathCoords[i].split(',');
                        pathCoords2d[i] = [parseFloat(bothCoords[0]), parseFloat(bothCoords[1])];

                    }

                    //find largest rectangle in polygon
                    if (pathCoords2d.length > 2) {
                        var rectangle = d3plus.geom.largestRect(pathCoords2d, {
                            angle: [0, 90, 180, 270], nTries: 1, tolerance: 0.02
                        });
                        svg.append("rect")
                                .attr("width", rectangle[0].width)
                                .attr("height", rectangle[0].height)
                                .attr("x", rectangle[0].cx - (rectangle[0].width / 2))
                                .attr("y", rectangle[0].cy - (rectangle[0].height / 2))
                                .attr("transform", "rotate(" + rectangle[0].angle + "," + rectangle[0].cx + "," + rectangle[0].cy + ")")
                                .attr("id", function() {
                                    return "rect_" + d.id;
                                })
                                .attr("fill", function() {
                                    var letters = '0123456789ABCDEF'.split('');
                                    var color = '#';
                                    for (var i = 0; i < 6; i++ ) {
                                        color += letters[Math.floor(Math.random() * 16)];
                                    }
                                    return color;
                                });

                        //append angle as text on to rectangle
                        svg.append("text").attr("x", rectangle[0].cx)
                                .attr("y", rectangle[0].cy)
                                .text(function(d) { return rectangle[0].angle; });

                        //find second rectangle--one that fits in remaining space
                        var rectTopYCoord = rectangle[0].cy + (rectangle[0].height / 2);
                        var rectRightXCoord = rectangle[0].cx + (rectangle[0].width / 2);
                        var rectLowYCoord = rectangle[0].cy - (rectangle[0].height / 2);
                        var rectLeftXCoord = rectangle[0].cx - (rectangle[0].width / 2);


                        console.log("rectangle.cy: " + rectangle[0].cy);
                        console.log("height: " + rectangle[0].height);
                        console.log("rectTopY: " + rectTopYCoord);

                        svg.append("circle").attr("cy", rectTopYCoord)
                                .attr("cx", rectRightXCoord)
                                .attr("r", 2);

                        svg.append("circle").attr("cy", rectTopYCoord)
                                .attr("cx", rectLeftXCoord)
                                .attr("r", 2);

                        svg.append("circle").attr("cy", rectLowYCoord)
                                .attr("cx", rectRightXCoord)
                                .attr("r", 2);

                        svg.append("circle").attr("cy", rectLowYCoord)
                                .attr("cx", rectLeftXCoord)
                                .attr("r", 2);

                        //find center of rectangle, save height / 2 and width / 2

                    }



                    //compare corners of rectangle with coords of poly--for each corner,
                    // compare:
                    // if (the y coordinate is higher (less) than top corner y coord?
                    //  save point as part of rectangle 1.
                    //else if (x coordinate is greater than right corner x coord?
                        //save point as part of rectangle 2.
                    //else if (y coordinate is lower (more) than bottom corner y coord)
                        //save point as part of rectangle 3.
                    //else if (x coordinate is less than left corner x cord)
                        //save point as part of rectangle 4.



                    return null;
                });






    });


</script>
</body>
</html>